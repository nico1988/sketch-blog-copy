{"pageProps":{"post":{"fileName":"2018-02-09_浅谈 JavaScript 闭包.md","id":"2018-02-09_浅谈 JavaScript 闭包","permalink":"20180209182319","tags":["js"],"title":"浅谈 JavaScript 闭包","date":"2018-02-09T18:23:19+08:00","categories":["笔记"],"cover":null,"pageview":281,"contentHtml":"<p>闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>\n<h2>闭包的特性</h2>\n<p>1.函数嵌套函数</p>\n<p>2.函数内部可以引用外部的参数和变量</p>\n<p>3.参数和变量不会被垃圾回收机制回收</p>\n<h2>闭包的定义及其优缺点</h2>\n<p>闭包 是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量</p>\n<p>闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>\n<p>闭包是javascript语言的一大特点，主要应用闭包场合主要是为了：设计私有的方法和变量。</p>\n<p>一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域。但闭包的情况不同！</p>\n<h2>嵌套函数的闭包</h2>\n<pre class=\"hljs\"><code>\nfunction aaa() {  \n\n    var a = 1\n    return function() {\n\n        alert(a++)\n\n    }\n\n} \n\nvar fun = aaa();  \n\nfun();// 1 执行后 a++，，然后a还在~  \n\nfun();// 2  \n\nfun = null;//a被回收！！\n\n</code></pre>\n<p>闭包会使变量始终保存在内存中，如果不当使用会增大内存消耗。</p>\n<h2>javascript的垃圾回收原理</h2>\n<p>1.在javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。</p>\n<p>2.如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。</p>\n<h2>使用闭包的好处</h2>\n<p>1.希望一个变量长期驻扎在内存中</p>\n<p>2.避免全局变量的污染</p>\n<p>3.私有成员的存在</p>\n<h2>1.全局变量的累加</h2>\n<pre class=\"hljs\"><code>\nvar a = 1;\n\nfunction abc(){\n\n    a++;\n\n    alert(a);\n\n}\n\nabc(); //2\n\nabc(); //3\n\n</code></pre>\n<h2>2.局部变量</h2>\n<pre class=\"hljs\"><code>\nfunction abc(){\n\n    var a = 1;\n\n    a++;\n\n    alert(a);\n\n}\n\nabc(); //2\n\nabc(); //2\n\n</code></pre>\n<h2>3.局部变量的累加</h2>\n<pre class=\"hljs\"><code>\nfunction outer(){\n\n    var x=10;\n\n    return function(){ //函数嵌套函数\n\n        x++;\n\n        alert(x);\n\n    }\n\n}\n\nvar y = outer(); //外部函数赋给变量y;\n\ny(); //y函数调用一次，结果为11，相当于outer()()；\n\ny(); //y函数调用第二次，结果为12，实现了累加\n\n</code></pre>\n<h2>4.模块化代码，减少全局变量的污染</h2>\n<pre class=\"hljs\"><code>\nvar abc = (function(){ //abc为外部匿名函数的返回值\n\n    var a = 1;\n\n    return function(){\n\n        a++;\n\n        alert(a);\n\n    }\n\n})();\n\nabc();    //2 ；调用一次abc函数，其实是调用里面内部函数的返回值    \n\nabc();    //3\n\n</code></pre>\n<h2>5.私有变量的存在</h2>\n<pre class=\"hljs\"><code>\nvar aaa = (function(){\n\n    var a = 1;\n\n    function bbb(){\n\n        a++;\n\n        alert(a);\n\n    }\n\n    function ccc(){\n\n        a--;\n\n        alert(a);\n\n    }\n\n    return {\n\n        b:bbb, \n\n        c:ccc\n\n    }\n\n})();\n\naaa.b();     //2\n\naaa.c()      //1\n\n</code></pre>\n<h2>6.使用匿名函数实现累加</h2>\n<pre class=\"hljs\"><code>\nfunction box(){\n\n    var age = 100;\n\n    return function(){          //匿名函数\n\n        age++;\n\n        return age;\n\n    }\n\n}\n\nvar b = box();\n\nalert(b()); //即alert(box()())；\n\nalert(b); \n\nb = null; //解除引用，等待垃圾回收\n\n</code></pre>\n<h2>7.在循环中添加点击事件</h2>\n<pre class=\"hljs\"><code>\nwindow.onload = function(){\n\n    var aLi = document.getElementsByTagName('li');\n\n    for (var i=0;i<aLi.length;i++){\n\n        aLi[i].onclick = function(){ //当点击时for循环已经结束\n\n            alert(i);\n\n        }\n\n    }\n\n}\n\n</code></pre>\n<h2>8.使用闭包改写上面代码</h2>\n<pre class=\"hljs\"><code>\nwindow.onload = function(){\n\n    var aLi = document.getElementsByTagName('li');\n\n    for (var i=0;i<aLi.length;i++){\n\n        (function(i){\n\n            aLi[i].onclick = function(){\n\n                alert(i);\n\n            }\n\n        })(i)\n\n    }\n\n}\n\n</code></pre>\n<h2>9.内存泄露问题</h2>\n<pre class=\"hljs\"><code>\nfunction closure(){\n\n    var oDiv = document.getElementById('oDiv');//oDiv用完之后一直驻留在内存中\n\n    oDiv.onclick = function () {\n\n        alert('oDiv.innerHTML');//这里用oDiv导致内存泄露\n\n    }\n\n}\n\nclosure();\n\n//最后应将oDiv解除引用来避免内存泄露\n\nfunction closure(){\n\n    var oDiv = document.getElementById('oDiv');\n\n    var test = oDiv.innerHTML;\n\n    oDiv.onclick = function () {\n\n        alert(test);\n\n    }\n\n    oDiv = null;\n\n}\n\n</code></pre>\n"}},"__N_SSG":true}